#Redis
##简介

##缓存雪崩
    如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了
    我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。
    如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。
    这就是缓存雪崩：Redis挂掉了，请求全部走数据库。
    缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！
###如何解决缓存雪崩？

    在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。
    对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：
    事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。
    事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
    事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

##缓存穿透
    缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。
    这就是缓存穿透：
    
    请求的数据在缓存大量不命中，导致请求走数据库。
    缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！

###如何解决缓存穿透？

    解决缓存穿透也有两种方案：

        由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！

        当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。

        这种情况我们一般会将空对象设置一个较短的过期时间。

##缓存与数据库双写一致
对于读操作，流程是这样的
如果我们的数据在缓存里边有，那么就直接取缓存的。

如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中。
最后将数据返回给请求。
    
    什么是缓存与数据库双写一致问题？
    
    如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。
    但是，当我们要更新时候呢？各种情况很可能就造成数据库和缓存的数据不一致了。
    这里不一致指的是：数据库的数据跟缓存的数据不一致

###如何解决缓存和数据库不一致问题
    从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。

    除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生

##redis的过期策略都有哪些？
###定期删除
    redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。
    
    假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，
    那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。
    
    注意这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。
    实际上redis是每隔100ms随机抽取一些key来检查和删除的。

###惰性删除
    惰性删除了就是说在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。

一般是配合定期删除和惰性删除一起使用

##内存淘汰机制都有哪些？
    no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错。
    
    allkeys-lru：当内存不足以容纳新写入数据时，在所有键空间中，移除最近最少使用的key（这个是最常用的）
    
    allkeys-random：当内存不足以容纳新写入数据时，在所有键空间中，随机移除某个key。
    
    volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）
    
    volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
    
    volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

#参考链接
https://blog.csdn.net/summerZBH123/article/details/81406856
https://blog.csdn.net/u011320646/article/details/85491103
https://www.cnblogs.com/lezon1995/p/11175380.html#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98
https://www.cnblogs.com/1013wang/p/12192610.html
https://www.cnblogs.com/jasontec/p/9699242.html
https://blog.csdn.net/Butterfly_resting/article/details/89668661



