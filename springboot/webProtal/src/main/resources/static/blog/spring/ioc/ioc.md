<p>
    <a href="#" onclick="refreshContent('spring')">返回目录</a>
</p>

#Spring ioc 知识积累

IOC 控制反转（Inversion of Control） 也可以称为依赖倒置

    依赖注入（Dependecy Injection）和控制反转（Inversion of Control）是同一个概念，
    具体的讲：当某个角色需要另外一个角色协助的时候，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。
    但在spring中创建被调用者的工作不再由调用者来完成，因此称为控制反转。创建被调用者的工作由spring来完成，然后注入调用者，因此也称为依赖注入。 
    
    使用IOC的好处
        集中管理，实现类的可配置和易管理。
        降低了类与类之间的耦合度
            
      通俗解释1：
      什么叫依赖注入控制反转啥的，我认为这一切都要建立在一个中心容器上面的，我们回来配置文件中，或者什么地方，约定好，什么接口的实现类是什么，约定好一些常量值。
      在我们有需要的时候，跟容器申请，那么申请回来的实现类是单例的，还是每次都是初始化的，这个也都是在配置文件约定好的。
      IOC 其实到这就差不多了，上面虽然没怎么说控制反转，其实也是说了的，什么是反转啊，反转了什么啊，以前的操作，我们就是各种 new 就完了，反转以后，不用 new 了，
      我们跟容器申请，这就是我理解的控制反转。
      有了 IOC 就有了 DI，这是个什么东西呢，在容器的初期，我们比如要 A，这个 A 依赖 B 和 C，我们就得从容器申请到 B 和 C，
      然后在申请 A 并把B 和 C 传递进去用来初始化 A，这本来没什么，毕竟程序员懒，不想这样复杂，所以就有了 DI，这东西是怎么运行的呢，就是利用反射技术，
      让容器自己分析依赖并且从容器中获取回来，并且初始化。由于 DI 用了反射，所以会使效率降低一些不过也有优化方案不用担心的
      
      
      通俗解释2：
      所谓依赖，从程序的角度看，就是比如A要调用B的方法，那么A就依赖于B，反正A要用到B，则A依赖于B。
      所谓倒置，你必须理解如果不倒置，会怎么着，因为A必须要有B，才可以调用B，如果不倒置，意思就是A主动获取B的实例：B b = new B()，
      这就是最简单的获取B实例的方法（当然还有各种设计模式可以帮助你去获得B的实例，比如工厂、Locator等等），然后你就可以调用b对象了。
      所以，不倒置，意味着A要主动获取B，才能使用B；到了这里，就应该明白了倒置的意思了。倒置就是A要调用B的话，A并不需要主动获取B，而是由其它人自动将B送上门来。
    
      形象的举例就是：
      通常情况下，假如你有一天在家里口渴了，要喝水，那么你可以到你小区的小卖部去，告诉他们，你需要一瓶水，然后小卖部给你一瓶水！
      这本来没有太大问题，关键是如果小卖部很远，那么你必须知道：从你家如何到小卖部；小卖部里是否有你需要的水；你还要考虑是否开着车去；
      等等等等，也许有太多的问题要考虑了。也就是说，为了一瓶水，你还可能需要依赖于车等等这些交通工具或别的工具，问题是不是变得复杂了？那么如何解决这个问题呢？
      解决这个问题的方法很简单：小卖部提供送货上门服务，凡是小卖部的会员，你只要告知小卖部你需要什么，小卖部将主动把货物给你送上门来！
      这样一来，你只需要做两件事情，你就可以活得更加轻松自在：
         第一：向小卖部注册为会员。
         第二：告诉小卖部你需要什么。
        
      当然，我们也可以使用注解来注入。Spring依赖注入的实现技术是：动态代理
      
      IOC的主要设计模式是工厂模式。


注入的两种方式，设置注入和构造注入。 

    设置注入的优点：直观，自然 
    构造注入的优点：可以在构造器中决定依赖关系的顺序
